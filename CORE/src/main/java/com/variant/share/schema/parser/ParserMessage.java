package com.variant.share.schema.parser;

import com.variant.share.error.UserError.Severity;

/**
 * Represents a message generated by Variant schema parser. Can be obtained via {@link ParserResponse#getMessages()}.
 * 
 * @since 0.5
 */
public interface ParserMessage {
	
	/**
	 * Severity of the message.
	 * 
	 * @return An object of type {@link Severity}.
	 * @since 0.5
	 */
	public Severity getSeverity();
	
	/**
	 * Text of the message.
	 * 
	 * @return The text of the message.
	 * @since 0.5
	 */
	public String getText();
	
	/**
	 * Internally assigned code of this message. For reference purposes only.
	 * 
	 * @return Code string.
	 * @since 0.5
	 */
	public int getCode();

	/**
	 * Location, in the schema source, where this message was detected. Most messages will have the location
	 * information, though some won't, e.g. "'/meta' clause is missing."
	 * 
	 * @return An object of type {@link Location}.
	 * @since 0.8
	 */
	public Location getLocation();

   /**
    * Some parse errors carry an interesting exception (e.g. failure to instantiate flusher or hook objects)
    * which we want to stash and later print in the log.
    * 
    * @return An object of type {@link Location}.
    * @since 0.8
    */
   public Exception getException();

   /**
	 * Location, in the schema source, where a parser message is emitted.
	 * Caller will be able to examine the implementation for methods which
	 * will help in identifying the exact location in the source file.
     *
     * @since 0.8
	 */
	public static interface Location {
		
		/**
		 * Path to the JSON element which emitted a parse error.
		 * <p>
		 * TODO: Explain path.
		 * 
		 * @return Path string, e.g. "/meta", or null if a syntax error.
		 * @since 0.8
		 */
		String getPath();
	}

}
