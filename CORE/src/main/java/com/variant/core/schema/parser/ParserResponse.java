package com.variant.core.schema.parser;

/*
import java.util.List;

import com.variant.core.UserError.Severity;
import com.variant.core.schema.ParserMessage;
import com.variant.core.schema.Schema;

/**
 * Represents the outcome of the XDM schema parsing operation.
 * Returned by {@link com.variant.core.Variant#parseSchema(java.io.InputStream, boolean)}.
 * Host code can obtain information about the outcome of the parsing operation.
 * 
 * @author Igor Urisman
 * @since 0.5
 * /////// No longer public, so we don't need the interface ////////
public interface ParserResponse {
	
	/**
	 * List of all parse messages in order they were emitted.
	 * @return A list of objects of type {@link ParserMessage}.
	 * @since 0.5
	 *
	List<ParserMessage> getMessages();

	/**
	 * Equivalent to <code>!{@link #getMessages()}.isEmpty()</code>.
	 * @return True there are messages of any severity, or false otherwise.
	 * @since 0.5
	 *
	boolean hasMessages();

	/**
	 * List of all parse messages of given severity or higher, in order they were emitted.
	 * @return A list of objects of type {@link ParserMessage}.
	 * @since 0.5
	 *
	List<ParserMessage> getMessages(Severity severity);

	/**
	 * Equivalent to <code>!{@link #getMessages(severity)}.isEmpty()</code>.
	 * @return True there are messages of given severity or higher, false otherwise.
	 * @since 0.5
	 *
	boolean hasMessages(Severity severity);
	
	/**
	 * Parsed schema.
	 * @return {@link Schema} object if no ERROR or FATAL severity message were generated by the parser, or null otherwise.
	 * @since 0.7
	 *
	Schema getSchema();
	
	/**
	 * Source schema.
	 * @return String containing the schema definition, if no ERROR or FATAL severity message were generated by the parser, or null otherwise.
	 * @since 0.7
	 *
	String getSchemaSrc();
}
*/

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.variant.core.UserError.Severity;
import com.variant.core.schema.ParserMessage;
import com.variant.core.schema.Schema;
import com.variant.core.schema.impl.SchemaImpl;
import com.variant.core.schema.parser.error.CollateralMessage;
import com.variant.core.schema.parser.error.SemanticError;
import com.variant.core.schema.parser.error.SyntaxError;

public class ParserResponse {

	private ArrayList<ParserMessage> messages = new ArrayList<ParserMessage>();
	private SchemaImpl schema = new SchemaImpl();
	private String schemaSrc = null;
	private MessageListener messageListener = null;
	
	/**
	 * Private common part of adding the message which posts the parser listener, if any.
	 * @param message
	 */
	private void addMessageCommon(ParserMessage message) {
		messages.add(message);
		if (messageListener != null) messageListener.messageAdded(message);
	}
	
	//---------------------------------------------------------------------------------------------//
	//                                          PUBLIC                                             //
	//---------------------------------------------------------------------------------------------//
	public static interface MessageListener {

		void messageAdded(ParserMessage message);
	}

	public ParserResponse() {}
	
   /**
	 * @return
	 */
	public List<ParserMessage> getMessages() {
		return Collections.unmodifiableList(messages);
	}

	public boolean hasMessages() {
		return ! messages.isEmpty();
	}

	/**
	 * @return
	 */
	public List<ParserMessage> getMessages(Severity severity) {
		ArrayList<ParserMessage> response = new ArrayList<ParserMessage>();
		for (ParserMessage msg: messages) {
			if (msg.getSeverity().greaterOrEqual(severity)) response.add(msg);
		}
		return Collections.unmodifiableList(response);
	}

	public boolean hasMessages(Severity severity) {
		return ! getMessages(severity).isEmpty();
	}

	public Schema getSchema() {
		return schema;
	}

	public String getSchemaSrc() {
		return schemaSrc;
	}

	/**
	 * Add a message generated externally by a parser time user hook.
	 *
    public void addMessage(Severity severity, String message) {
		ParserMessage result = new ParserMessageImpl(new ParserHookError(severity, message));
		addMessageCommon(result);
	}

	/**
	 * Add a syntax error.
	 */
	public ParserMessage addMessage(SyntaxError error, SyntaxError.Location location, String...args) {
		
		ParserMessage result = new ParserMessageImpl(location, error, args);
		addMessageCommon(result);
		return result;
	}

	/**
	 * Add a simantic error.
	 */
	public ParserMessage addMessage(SemanticError error, SemanticError.Location location, String...args) {
		
		ParserMessage result = new ParserMessageImpl(location, error, args);
		addMessageCommon(result);
		return result;
	}

	/**
	 * Collateral messages, emitted or caused by user code.
	 * @param error
	 */
	public ParserMessage addMessage(CollateralMessage error, String...args) {
		ParserMessage result = new ParserMessageImpl(null, error, args);
		addMessageCommon(result);
		return result;
	}

	/**
	 * 
	 * @param schemaSrc
	 */
	public void setSchemaSrc(String schemaSrc) {
		this.schemaSrc = schemaSrc;
	}
	
	/**
	 * Clear the schema in progress, at the end of an unsuccessful parse.
	 */
	public void clearSchema() {
		schema = null;
		schemaSrc = null;
	}
	
	/**
	 * 
	 * @param listener
	 */
	public void setMessageListener(MessageListener listener) {
		this.messageListener = listener;
	}
}
